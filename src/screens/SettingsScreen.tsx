import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  TextInput,
  ScrollView,
  Image,
  Switch,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import * as ImagePicker from 'expo-image-picker';
import { signOutFn } from '../api/auth';
import { UsersAPI, InvitesAPI } from '../api';
import type { NotificationPreferences } from '../api/users';
import { Avatar } from '../components/Avatar';
import { uploadMedia } from '../lib/upload';
import { mediaUrlFromKey, deleteMedia } from '../lib/media';
import { readStoredInviteCode, writeStoredInviteCode } from '../lib/storage';
import { useTheme } from '../theme';

type ViewerProfile = {
  fullName?: string | null;
  avatarKey?: string | null;
  inviteCode?: string | null;
};

type LoadViewerOptions = {
  silent?: boolean;
};

export default function SettingsScreen({ navigation }: any) {
  const { mode, setTheme, colors } = useTheme();
  const [loading, setLoading] = React.useState(true);
  const [saving, setSaving] = React.useState(false);
  const [uploading, setUploading] = React.useState(false);
  const [fullName, setFullName] = React.useState('');
  const [avatarKey, setAvatarKey] = React.useState<string | null>(null);
  const [inviteCode, setInviteCode] = React.useState<string | null>(null);
  const [initialFullName, setInitialFullName] = React.useState('');
  const [initialAvatarKey, setInitialAvatarKey] = React.useState<string | null>(null);
  const [avatarPreviewUri, setAvatarPreviewUri] = React.useState<string | null>(null);
  const [saved, setSaved] = React.useState(false);
  const [notificationPrefs, setNotificationPrefs] = React.useState<NotificationPreferences>({
    mentions: true,
    comments: true,
    reactions: true,
  });
  const [loadingPrefs, setLoadingPrefs] = React.useState(false);

  const ensureInviteCode = React.useCallback(
    async (viewerId?: string | null): Promise<string | null> => {
      const normalizedId = typeof viewerId === 'string' ? viewerId.trim() : '';
      if (normalizedId) {
        const cached = await readStoredInviteCode(normalizedId);
        if (cached) {
          return cached;
        }
      }

      // Try to list existing invites first
      try {
        if (InvitesAPI.listInvites) {
          const existing = await InvitesAPI.listInvites();
          const existingCode = UsersAPI.findInviteCode?.(existing) ?? null;
          if (existingCode) {
            if (normalizedId) {
              await writeStoredInviteCode(normalizedId, existingCode);
            }
            return existingCode;
          }
        }
      } catch (error: any) {
        // Silently continue if listing fails - we'll try to create
        const errorMsg = error?.message || String(error);
        console.log('[Invites] Could not list invites, will try to create:', errorMsg);
      }

      // Try to create a new invite code
      try {
        const payload = await InvitesAPI.createInvite(10);
        const code = UsersAPI.findInviteCode?.(payload) ?? null;
        const fallback =
          payload && typeof payload === 'object' && 'code' in (payload as any)
            ? String((payload as any).code)
            : null;
        const normalizedCode = code || (fallback && fallback.trim().length > 0 ? fallback.trim() : null);
        if (normalizedCode && normalizedId) {
          await writeStoredInviteCode(normalizedId, normalizedCode);
        }
        return normalizedCode ?? null;
      } catch (error: any) {
        const errorMsg = error?.message || String(error);

        if (errorMsg.includes('INVITE_CREATE_FORBIDDEN') || errorMsg.includes('403')) {
          console.log('[Invites] User cannot create invites - may be auto-generated by backend');
        } else if (errorMsg.includes('404')) {
          console.log('[Invites] Invite endpoints not found - backend may not support user invites yet');
        } else {
          console.warn('[Invites] Unexpected error:', errorMsg);
        }

        return null;
      }
    },
    []
  );

  const loadViewer = React.useCallback(async (options?: LoadViewerOptions) => {
    if (!options?.silent) {
      setLoading(true);
    }
    try {
      const data: ViewerProfile | null = await UsersAPI.me();
      const normalizedFullName =
        data && typeof data.fullName === 'string' ? data.fullName : '';
      const normalizedAvatarKey = data?.avatarKey ?? null;
      const normalizedId =
        data && typeof (data as any).id === 'string' && (data as any).id.trim().length
          ? (data as any).id.trim()
          : null;
      let normalizedInviteCode =
        data && typeof data.inviteCode === 'string' && data.inviteCode.trim().length
          ? data.inviteCode.trim()
          : null;

      if (!normalizedInviteCode && normalizedId) {
        normalizedInviteCode = await readStoredInviteCode(normalizedId);
      }

      if (!normalizedInviteCode) {
        normalizedInviteCode = await ensureInviteCode(normalizedId);
      }

      setFullName(normalizedFullName);
      setInitialFullName(normalizedFullName);
      setAvatarKey(normalizedAvatarKey);
      setInitialAvatarKey(normalizedAvatarKey);
      setInviteCode(normalizedInviteCode);
      setAvatarPreviewUri(null);

      if (normalizedInviteCode && normalizedId) {
        await writeStoredInviteCode(normalizedId, normalizedInviteCode);
      }
    } catch (error: any) {
      console.error('Failed to load profile:', error);
      Alert.alert('Error', error?.message || 'Unable to load settings.');
    } finally {
      setLoading(false);
    }
  }, [ensureInviteCode]);

  React.useEffect(() => {
    loadViewer();
    loadNotificationPreferences();
  }, [loadViewer]);

  const loadNotificationPreferences = React.useCallback(async () => {
    try {
      const prefs = await UsersAPI.getNotificationPreferences();
      setNotificationPrefs(prefs);
    } catch (error: any) {
      console.error('Failed to load notification preferences:', error);
      // Keep default values on error
    }
  }, []);

  const handlePreferenceChange = React.useCallback(async (key: keyof NotificationPreferences, value: boolean) => {
    // Optimistic update
    setNotificationPrefs(prev => ({ ...prev, [key]: value }));
    setLoadingPrefs(true);

    try {
      const updated = await UsersAPI.updateNotificationPreferences({ [key]: value });
      setNotificationPrefs(updated);
    } catch (error: any) {
      console.error('Failed to update notification preference:', error);
      Alert.alert('Error', 'Failed to update notification preferences. Please try again.');
      // Revert on error
      await loadNotificationPreferences();
    } finally {
      setLoadingPrefs(false);
    }
  }, [loadNotificationPreferences]);

  // Cleanup: Delete newly uploaded avatar if user navigates away without saving
  React.useEffect(() => {
    return () => {
      const hasNewAvatar = avatarKey && avatarKey !== initialAvatarKey;
      if (hasNewAvatar && !saved) {
        deleteMedia(avatarKey)
          .then(() => console.log('Cleaned up unused uploaded avatar:', avatarKey))
          .catch((error) => console.warn('Failed to cleanup unused avatar:', error));
      }
    };
  }, [avatarKey, initialAvatarKey, saved]);

  const handleLogout = async () => {
    try {
      await signOutFn();
      navigation.reset({ index: 0, routes: [{ name: 'Login' }] });
    } catch (error: any) {
      Alert.alert('Error', error?.message || 'Failed to sign out.');
    }
  };

  const handleDeleteAccount = () => {
    Alert.alert(
      'Delete Account',
      'Are you sure you want to delete your account? This will permanently delete all your posts, comments, reactions, and remove you from the system. This action cannot be undone.',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: confirmDeleteAccount,
        },
      ]
    );
  };

  const confirmDeleteAccount = async () => {
    try {
      setSaving(true);
      await UsersAPI.deleteAccount();

      // Sign out and navigate to login screen
      await signOutFn();
      navigation.reset({ index: 0, routes: [{ name: 'Login' }] });

      Alert.alert('Account Deleted', 'Your account has been successfully deleted.');
    } catch (error: any) {
      console.error('Failed to delete account:', error);
      Alert.alert('Error', error?.message || 'Failed to delete account. Please try again.');
    } finally {
      setSaving(false);
    }
  };

  const uploadAvatar = React.useCallback(
    async (uri: string) => {
      setUploading(true);
      try {
        const key = await uploadMedia({ uri, intent: 'avatar-image' });
        setAvatarKey(key);
        const remotePreview = mediaUrlFromKey(key);
        setAvatarPreviewUri(remotePreview ?? uri);
      } catch (error: any) {
        console.error('[SettingsScreen] Failed to upload avatar:', error);
        Alert.alert('Error', error?.message || 'Failed to upload profile photo.');
        setAvatarPreviewUri(null);
      } finally {
        setUploading(false);
      }
    },
    []
  );

  const pickImage = React.useCallback(
    async (fromCamera: boolean) => {
      try {
        let result;
        if (fromCamera) {
          const { status } = await ImagePicker.requestCameraPermissionsAsync();
          if (status !== 'granted') {
            Alert.alert('Permission needed', 'Camera permission is required.');
            return;
          }
          result = await ImagePicker.launchCameraAsync({
            mediaTypes: 'images',
            quality: 0.8,
            allowsEditing: true,
            aspect: [1, 1],
          });
        } else {
          const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
          if (status !== 'granted') {
            Alert.alert('Permission needed', 'Photo library permission is required.');
            return;
          }
          result = await ImagePicker.launchImageLibraryAsync({
            mediaTypes: 'images',
            quality: 0.8,
            allowsEditing: true,
            aspect: [1, 1],
          });
        }

        if (!result.canceled && result.assets?.[0]?.uri) {
          const uri = result.assets[0].uri;
          setAvatarPreviewUri(uri);
          await uploadAvatar(uri);
        }
      } catch (error: any) {
        console.error('Error selecting image:', error);
        Alert.alert('Error', 'Failed to select image.');
      }
    },
    [uploadAvatar]
  );

  const showImageOptions = () => {
    Alert.alert('Update profile photo', 'Choose an option', [
      { text: 'Camera', onPress: () => pickImage(true) },
      { text: 'Photo library', onPress: () => pickImage(false) },
      { text: 'Cancel', style: 'cancel' },
    ]);
  };

  const removePhoto = () => {
    if (!avatarKey && !avatarPreviewUri) {
      return;
    }
    Alert.alert('Remove photo', 'Are you sure you want to remove your profile photo?', [
      { text: 'Cancel', style: 'cancel' },
      {
        text: 'Remove',
        style: 'destructive',
        onPress: () => {
          setAvatarKey(null);
          setAvatarPreviewUri(null);
        },
      },
    ]);
  };

  const handleSaveAvatar = async () => {
    const hasAvatarChange = (avatarKey ?? null) !== (initialAvatarKey ?? null);

    if (!hasAvatarChange) {
      Alert.alert('No changes', 'Please update your profile photo first.');
      return;
    }

    setSaving(true);
    try {
      // Delete old avatar from S3 if it's being replaced with a new one
      if (initialAvatarKey && avatarKey && initialAvatarKey !== avatarKey) {
        try {
          await deleteMedia(initialAvatarKey);
          console.log('Deleted old avatar from S3:', initialAvatarKey);
        } catch (error) {
          console.warn('Failed to delete old avatar:', error);
          // Continue with save even if deletion fails
        }
      }

      await UsersAPI.updateAvatar(avatarKey ?? null);
      setSaved(true); // Mark as saved so cleanup doesn't delete the new avatar
      await loadViewer({ silent: true });
      Alert.alert('Success', 'Profile photo updated successfully');
    } catch (error: any) {
      console.error('Failed to save avatar:', error);
      Alert.alert('Error', error?.message || 'Failed to update profile photo.');
    } finally {
      setSaving(false);
    }
  };

  const handleSaveName = async () => {
    const trimmedName = fullName.trim();
    const normalizedName = trimmedName.length ? trimmedName : '';
    const hasNameChange = normalizedName !== initialFullName.trim();

    if (!hasNameChange) {
      Alert.alert('No changes', 'Please update your name first.');
      return;
    }

    setSaving(true);
    try {
      await UsersAPI.updateMe({ fullName: trimmedName.length ? trimmedName : null });
      await loadViewer({ silent: true });
      Alert.alert('Success', 'Name updated successfully');
    } catch (error: any) {
      console.error('Failed to save name:', error);
      Alert.alert('Error', error?.message || 'Failed to update your name.');
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={[styles.loadingContainer, { backgroundColor: colors.background.primary }]}>
        <ActivityIndicator size="large" color={colors.primary[500]} />
      </View>
    );
  }

  const inviteCodeLabel = inviteCode || 'Not available yet';

  return (
    <SafeAreaView style={[styles.safeArea, { backgroundColor: colors.background.secondary }]} edges={['bottom']}>
      <ScrollView contentContainerStyle={styles.container} keyboardShouldPersistTaps="handled">
        <Text style={[styles.title, { color: colors.text.primary }]}>Settings</Text>

        <View style={styles.section}>
          <Text style={[styles.sectionLabel, { color: colors.text.primary }]}>Profile photo</Text>
          <View style={styles.avatarRow}>
            <View style={styles.avatarWrapper}>
              {avatarPreviewUri ? (
                <Image source={{ uri: avatarPreviewUri }} style={styles.avatarImage} />
              ) : (
                <Avatar avatarKey={avatarKey} size={88} />
              )}
              {uploading && (
                <View style={styles.avatarOverlay}>
                  <ActivityIndicator color="#fff" />
                </View>
              )}
            </View>
            <View style={styles.avatarActions}>
              <TouchableOpacity
                style={[styles.secondaryButton, uploading && styles.disabledButton]}
                onPress={showImageOptions}
                disabled={uploading}
              >
                <Text style={styles.secondaryButtonText}>
                  {uploading ? 'Uploading…' : 'Change photo'}
                </Text>
              </TouchableOpacity>
              {(avatarKey || avatarPreviewUri) && (
                <>
                  <TouchableOpacity
                    onPress={removePhoto}
                    disabled={uploading}
                    style={styles.linkButton}
                  >
                    <Text style={[styles.linkButtonText, uploading && styles.linkButtonDisabled]}>Remove photo</Text>
                  </TouchableOpacity>
                  {(avatarKey ?? null) !== (initialAvatarKey ?? null) && (
                    <TouchableOpacity
                      style={[styles.inlineSaveButton, (saving || uploading) && styles.disabledButton]}
                      onPress={handleSaveAvatar}
                      disabled={saving || uploading}
                    >
                      {saving ? (
                        <ActivityIndicator size="small" color="#fff" />
                      ) : (
                        <Text style={styles.inlineSaveButtonText}>Save photo</Text>
                      )}
                    </TouchableOpacity>
                  )}
                </>
              )}
            </View>
          </View>
        </View>

        <View style={styles.section}>
          <Text style={[styles.sectionLabel, { color: colors.text.primary }]}>Full name</Text>
          <View style={styles.inputRow}>
            <TextInput
              style={[styles.input, { backgroundColor: colors.background.elevated, color: colors.text.primary, borderColor: colors.border.main }]}
              value={fullName}
              onChangeText={setFullName}
              placeholder="Enter your full name"
              placeholderTextColor={colors.text.tertiary}
              autoCapitalize="words"
              editable={!saving && !uploading}
            />
            {fullName.trim() !== initialFullName.trim() && (
              <TouchableOpacity
                style={[styles.inlineSaveButton, saving && styles.disabledButton]}
                onPress={handleSaveName}
                disabled={saving}
              >
                {saving ? (
                  <ActivityIndicator size="small" color="#fff" />
                ) : (
                  <Text style={styles.inlineSaveButtonText}>Save</Text>
                )}
              </TouchableOpacity>
            )}
          </View>
        </View>

        <View style={styles.section}>
          <Text style={[styles.sectionLabel, { color: colors.text.primary }]}>Invite code</Text>
          <View style={[styles.inviteCodeBox, { backgroundColor: colors.background.elevated, borderColor: colors.border.main }]}>
            <Text selectable={!!inviteCode} style={[styles.inviteCodeText, { color: inviteCode ? colors.text.primary : colors.text.tertiary }]}>
              {inviteCodeLabel}
            </Text>
          </View>
          <Text style={[styles.inviteHint, { color: colors.text.secondary }]}>
            {inviteCode
              ? 'Share this code with friends to invite them.'
              : 'Your invite code will appear here once generated by the system.'}
          </Text>
        </View>

        <View style={styles.section}>
          <Text style={[styles.sectionLabel, { color: colors.text.primary }]}>Appearance</Text>

          <TouchableOpacity
            style={[styles.themeOption, mode === 'light' && styles.themeOptionActive, { backgroundColor: colors.background.elevated, borderColor: mode === 'light' ? colors.primary[500] : colors.border.main }]}
            onPress={() => setTheme('light')}
          >
            <Text style={[styles.themeOptionText, { color: colors.text.primary }]}>Light</Text>
            {mode === 'light' && (
              <Text style={[styles.themeCheck, { color: colors.primary[500] }]}>✓</Text>
            )}
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.themeOption, mode === 'dark' && styles.themeOptionActive, { backgroundColor: colors.background.elevated, borderColor: mode === 'dark' ? colors.primary[500] : colors.border.main }]}
            onPress={() => setTheme('dark')}
          >
            <Text style={[styles.themeOptionText, { color: colors.text.primary }]}>Dark</Text>
            {mode === 'dark' && (
              <Text style={[styles.themeCheck, { color: colors.primary[500] }]}>✓</Text>
            )}
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.themeOption, mode === 'system' && styles.themeOptionActive, { backgroundColor: colors.background.elevated, borderColor: mode === 'system' ? colors.primary[500] : colors.border.main }]}
            onPress={() => setTheme('system')}
          >
            <Text style={[styles.themeOptionText, { color: colors.text.primary }]}>Match system setting</Text>
            {mode === 'system' && (
              <Text style={[styles.themeCheck, { color: colors.primary[500] }]}>✓</Text>
            )}
          </TouchableOpacity>
        </View>

        <View style={styles.section}>
          <Text style={[styles.sectionLabel, { color: colors.text.primary }]}>Notifications</Text>
          <Text style={[styles.inviteHint, { color: colors.text.secondary, marginTop: -8, marginBottom: 12 }]}>
            Changes are saved automatically
          </Text>

          <View style={[styles.settingRow, { backgroundColor: colors.background.elevated, borderColor: colors.border.main }]}>
            <View style={styles.settingTextContainer}>
              <Text style={[styles.settingLabel, { color: colors.text.primary }]}>Mentions</Text>
              <Text style={[styles.settingDescription, { color: colors.text.secondary }]}>
                Notify me when someone mentions me
              </Text>
            </View>
            <Switch
              value={notificationPrefs.mentions}
              onValueChange={(value) => handlePreferenceChange('mentions', value)}
              disabled={loadingPrefs}
              trackColor={{ false: colors.neutral[300], true: colors.primary[500] }}
              thumbColor={colors.background.primary}
            />
          </View>

          <View style={[styles.settingRow, { backgroundColor: colors.background.elevated, borderColor: colors.border.main }]}>
            <View style={styles.settingTextContainer}>
              <Text style={[styles.settingLabel, { color: colors.text.primary }]}>Comments</Text>
              <Text style={[styles.settingDescription, { color: colors.text.secondary }]}>
                Notify me when someone comments on my posts
              </Text>
            </View>
            <Switch
              value={notificationPrefs.comments}
              onValueChange={(value) => handlePreferenceChange('comments', value)}
              disabled={loadingPrefs}
              trackColor={{ false: colors.neutral[300], true: colors.primary[500] }}
              thumbColor={colors.background.primary}
            />
          </View>

          <View style={[styles.settingRow, { backgroundColor: colors.background.elevated, borderColor: colors.border.main }]}>
            <View style={styles.settingTextContainer}>
              <Text style={[styles.settingLabel, { color: colors.text.primary }]}>Reactions</Text>
              <Text style={[styles.settingDescription, { color: colors.text.secondary }]}>
                Notify me when someone reacts to my posts
              </Text>
            </View>
            <Switch
              value={notificationPrefs.reactions}
              onValueChange={(value) => handlePreferenceChange('reactions', value)}
              disabled={loadingPrefs}
              trackColor={{ false: colors.neutral[300], true: colors.primary[500] }}
              thumbColor={colors.background.primary}
            />
          </View>
        </View>

        <TouchableOpacity
          style={styles.deleteAccountButton}
          onPress={handleDeleteAccount}
          disabled={saving || uploading}
        >
          <Text style={[styles.deleteAccountButtonText, (saving || uploading) && styles.deleteAccountButtonDisabled]}>
            Delete Account
          </Text>
        </TouchableOpacity>

        <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
          <Text style={styles.logoutButtonText}>Log out</Text>
        </TouchableOpacity>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#f5f7fa',
  },
  container: {
    padding: 20,
    paddingBottom: 40,
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
    marginBottom: 24,
  },
  section: {
    marginBottom: 24,
  },
  sectionLabel: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 12,
  },
  settingRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
    marginBottom: 12,
  },
  settingTextContainer: {
    flex: 1,
    marginRight: 12,
  },
  settingLabel: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
  },
  settingDescription: {
    fontSize: 14,
    color: '#666',
  },
  themeOption: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderRadius: 12,
    borderWidth: 2,
    marginBottom: 12,
  },
  themeOptionActive: {
    borderWidth: 2,
  },
  themeOptionText: {
    fontSize: 16,
    fontWeight: '500',
  },
  themeCheck: {
    fontSize: 20,
    fontWeight: '700',
  },
  avatarRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatarWrapper: {
    width: 88,
    height: 88,
    borderRadius: 44,
    overflow: 'hidden',
    position: 'relative',
    marginRight: 20,
  },
  avatarImage: {
    width: '100%',
    height: '100%',
    borderRadius: 44,
  },
  avatarOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.4)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  avatarActions: {
    flex: 1,
    alignItems: 'flex-start',
  },
  secondaryButton: {
    borderWidth: 1,
    borderColor: '#2196f3',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  secondaryButtonText: {
    color: '#2196f3',
    fontWeight: '600',
  },
  disabledButton: {
    opacity: 0.6,
  },
  linkButton: {
    paddingVertical: 4,
    marginTop: 4,
  },
  linkButtonText: {
    color: '#e53935',
    fontWeight: '600',
  },
  linkButtonDisabled: {
    color: '#e57373',
  },
  inputRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  input: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#d0d7de',
    borderRadius: 10,
    paddingHorizontal: 14,
    paddingVertical: 12,
    backgroundColor: '#fff',
    fontSize: 16,
  },
  inlineSaveButton: {
    backgroundColor: '#4F46E5',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 8,
    minWidth: 80,
    alignItems: 'center',
    justifyContent: 'center',
  },
  inlineSaveButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '600',
  },
  inviteCodeBox: {
    borderWidth: 1,
    borderStyle: 'dashed',
    borderColor: '#90caf9',
    borderRadius: 10,
    padding: 16,
    backgroundColor: '#e3f2fd',
  },
  inviteCodeText: {
    fontSize: 18,
    fontWeight: '700',
    textAlign: 'center',
    letterSpacing: 1,
  },
  inviteHint: {
    marginTop: 8,
    color: '#607d8b',
    fontSize: 13,
  },
  deleteAccountButton: {
    marginTop: 32,
    alignItems: 'center',
  },
  deleteAccountButtonText: {
    color: '#e53935',
    fontSize: 16,
    fontWeight: '600',
  },
  deleteAccountButtonDisabled: {
    opacity: 0.5,
  },
  logoutButton: {
    marginTop: 16,
    alignItems: 'center',
  },
  logoutButtonText: {
    color: '#e53935',
    fontSize: 16,
    fontWeight: '600',
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
});
